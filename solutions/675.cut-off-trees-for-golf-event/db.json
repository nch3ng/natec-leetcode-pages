{"python":"from collections import deque\nclass Solution:\n    d = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def cutOffTree(self, forest):\n        #print(forest)\n        rows = len(forest)\n        if rows == 0:\n            return 0\n\n        cols = len(forest[0])\n        if cols == 0:\n            return 0\n\n        forest.append([0] * cols)\n        for row in forest:\n            row.append(0)\n\n        trees = {(r, c) for c in range(cols) for r in range(rows) if forest[r][c] > 1}\n\n        visited = {(0, 0)}\n        queue = [(0, 0)]\n        while len(queue) != 0:\n            r, c = queue.pop()\n            for nr, nc in ((r + dr, c + dc) for dr, dc in self.d):\n                if (nr, nc) not in visited and forest[nr][nc] > 0:\n                    visited.add((nr, nc))\n                    queue.append((nr, nc))\n\n        if trees.difference(visited):\n            return -1\n\n        trees = sorted(trees, key=lambda t: forest[t[0]][t[1]])\n        if trees[0] != (0, 0):\n            trees.insert(0, (0, 0))\n        num_trees = len(trees)\n        #print('TREES:', trees)\n\n        total_steps = 0\n        for i in range(1, num_trees):\n            pr, pc = p = trees[i - 1]\n            qr, qc = q = trees[i]\n            cost = abs(pr - qr) + abs(pc - qc)\n\n            queue, next_queue = [], [] # Using list: 0.53s, 0.52s, 0.54s\n            #queue, next_queue = deque(), deque() # Using deque: 1.45s, 1.50s, 1.46s\n            queue.append(p)\n            visited, pending_visited = {p}, set()\n            while len(queue) + len(next_queue) != 0:\n                if len(queue) == 0:\n                    queue = next_queue\n                    next_queue = deque()\n\n                    visited.update(pending_visited)\n                    pending_visited = set()\n                    cost += 2\n\n                (r, c) = queue.pop() # Using list\n                #(r, c) = queue.popleft() # Using deque\n                #print('POP', r, c, cost)\n\n                safe_dr = qr - r\n                safe_dr = safe_dr and safe_dr // abs(safe_dr)\n                safe_dc = qc - c\n                safe_dc = safe_dc and safe_dc // abs(safe_dc)\n                for dr, dc in self.d:\n                    nbr = (r + dr, c + dc)\n                    if nbr not in visited and forest[nbr[0]][nbr[1]] > 0:\n                        #print('SAFE', (safe_dr, safe_dc), 'D', (dr, dc))\n                        if (dr == safe_dr and dc != -safe_dc) or (dc == safe_dc and dr != -safe_dr):\n                            queue.append(nbr)\n                            visited.add(nbr)\n                            ncost = cost\n                            #print('PUSH', nbr)\n                        else:\n                            next_queue.append(nbr)\n                            pending_visited.add(nbr)\n                            ncost = cost + 2\n                            #print('PUSH NEXT', nbr)\n                        if nbr == q:\n                            #print('COST:', p, q, ncost)\n                            total_steps += ncost\n                            queue = next_queue = list()\n                            break\n\n                # print('MAP', cost)\n                # for rr in range(rows):\n                #     for cc in range(cols):\n                #         if (rr, cc) == (r, c):\n                #             print('*', end='')\n                #         elif (rr, cc) in queue:\n                #             print('Q', end='')\n                #         elif (rr, cc) in visited:\n                #             print('+', end='')\n                #         elif (rr, cc) in next_queue:\n                #             print('N', end='')\n                #         else:\n                #             print(forest[rr][cc], end='')\n                #     print()\n\n        return total_steps"}