{"python":"from collections import deque\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if not root:\n          return []\n        \n        if not root.left and not root.right:\n          return [root.val]\n\n        ans = []\n        stack = deque()\n        \n        node = root\n        stack.append(node)\n        while stack:\n          node = stack.popleft()\n          if node:\n            ans.append(node.val)\n            stack.append(node.left)\n            stack.append(node.right)\n          else:\n            ans.append(None)\n\n        # trim the end\n        while ans[-1] == None:\n          ans.pop()\n\n        return ans\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        root = None\n\n        if not data:\n          return root\n\n        node_queue = deque()\n        list = deque(data)\n        val = list.popleft()\n        \n        if val != None:\n          root = TreeNode(val)\n\n        node_queue.append(root)\n        print(node_queue)\n        while list:\n          t = node_queue.popleft() # start with root\n          left = list.popleft()\n          if list:\n            right = list.popleft()\n          else:\n            right = None\n\n\n          if left != None:\n            t.left = TreeNode(left)\n            node_queue.append(t.left)\n\n          if right != None:\n            t.right = TreeNode(right)\n            node_queue.append(t.right)\n          \n        return root\n","ruby":"# Definition for a binary tree node.\r\n# class TreeNode\r\n#     attr_accessor :val, :left, :right\r\n#     def initialize(val)\r\n#         @val = val\r\n#         @left, @right = nil, nil\r\n#     end\r\n# end\r\n\r\n# Encodes a tree to a single string.\r\n#\r\n# @param {TreeNode} root\r\n# @return {string}\r\ndef serialize(root) \r\n    q=[]\r\n    ans = []\r\n    return root if root.nil?\r\n    \r\n    q.push(root)\r\n    until q.empty?\r\n        t = q.shift\r\n        if t.nil?\r\n            ans.push(nil)\r\n        else\r\n            ans.push(t.val)\r\n            \r\n            if t.left.nil?\r\n                q.push(nil)\r\n            else\r\n                q.push(t.left) \r\n            end\r\n            \r\n            if t.right.nil?\r\n                q.push(nil)\r\n            else\r\n                q.push(t.right) \r\n            end\r\n        end\r\n    \r\n    end\r\n    ans\r\nend\r\n\r\n# Decodes your encoded data to tree.\r\n#\r\n# @param {string} data\r\n# @return {TreeNode}\r\ndef deserialize(data)\r\n    return data if data.nil?\r\n    q=[]\r\n    \r\n    root = TreeNode.new(data.shift)\r\n    q.push(root)\r\n  \r\n    until data.empty?\r\n        t = q.shift\r\n        l = data.shift\r\n        r = data.shift\r\n  \r\n    unless l.nil?\r\n        t.left = TreeNode.new(l)\r\n        q.push(t.left)\r\n    end\r\n    \r\n    unless r.nil?\r\n        t.right = TreeNode.new(r)\r\n        q.push(t.right)\r\n    end\r\n    \r\n  end\r\n  root\r\nend\r\n\r\n# Your functions will be called as such:\r\n# deserialize(serialize(data))"}