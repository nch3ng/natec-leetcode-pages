{"ruby":"# Definition for a binary tree node.\r\n# class TreeNode\r\n#     attr_accessor :val, :left, :right\r\n#     def initialize(val)\r\n#         @val = val\r\n#         @left, @right = nil, nil\r\n#     end\r\n# end\r\n\r\n# @param {TreeNode} root\r\n# @return {Integer[]}\r\ndef postorder_traversal(root)\r\n    s1 = []\r\n    s2 = []\r\n    return s2 if root.nil?\r\n    \r\n    s1.push(root)\r\n    \r\n    until s1.empty?\r\n        r = s1.pop()\r\n        s2.push(r.val)\r\n        \r\n        s1.push(r.left) unless r.left.nil?\r\n        s1.push(r.right) unless r.right.nil?\r\n    end\r\n    s2.reverse\r\nend","python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = []\n\n        if root == None:\n            return []\n\n        s = []\n\n\n        s.append(root)\n        while s:\n            node = s.pop()\n            ans.append(node.val)\n\n            if node.left != None:\n                s.append(node.left)\n                \n            if node.right != None:\n                s.append(node.right)\n\n        ans.reverse()\n    \n        return ans\n"}